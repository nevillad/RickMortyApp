//
//  ListViewViewController.swift
//  RickMortyApp
//
//  Created by Nevilkumar Lad on 06/01/22.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ListDisplayLogic: class {
    func displayFetchFromLocalDataStore(with viewModel: ListModels.FetchFromLocalDataStore.ViewModel)
    func displayFetchFromRemoteDataStore(with viewModel: ListModels.FetchFromRemoteDataStore.ViewModel)
    func displayLoader(type: ListLoaderType)
    func hideLoader(type: ListLoaderType)
    func displayError(type: ListErrorType)
}

class ListViewController: BaseViewController, ListDisplayLogic {

    // MARK: - Properties

    typealias Models = ListModels
    var router: (NSObjectProtocol & ListRoutingLogic & ListDataPassing)?
    var interactor: ListBusinessLogic?

    class func instantiateFromStoryboard() -> ListViewController {
        let storyboard = UIStoryboard(name: "Main", bundle: nil)
        return storyboard.instantiateViewController(withIdentifier: String(describing: self)) as! ListViewController
    }

    // MARK: - Outlets
    @IBOutlet weak var tvList: UITableView!

    // MARK: - Object lifecycle

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    // MARK: - Setup

    private func setup() {
        let viewController = self
        let interactor = ListInteractor()
        let presenter = ListPresenter()
        let router = ListRouter()

        viewController.router = router
        viewController.interactor = interactor
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    // MARK: - View Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        self.title = router?.dataStore?.screenTitle
        registerCustomTableViewCell()
        setupFetchFromLocalDataStore()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        setupFetchFromRemoteDataStore()
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
    }

    // MARK: - TableView Cells

    func registerCustomTableViewCell() {
        tvList.delegate = self
        tvList.dataSource = self
        tvList.separatorStyle = .none
        tvList.register(UINib(nibName: CUSTOM_TABLEVIEW_CELL_ID, bundle: Bundle.init(for: CustomTableViewCell.self)), forCellReuseIdentifier: CUSTOM_TABLEVIEW_CELL_ID)
        tvList.register(UINib(nibName: LOADING_TABLEVIEW_CELL_ID, bundle: Bundle.init(for: LoadingTableViewCell.self)), forCellReuseIdentifier: LOADING_TABLEVIEW_CELL_ID)
        tvList.backgroundColor = Color.lightBackground.value
        tvList.rowHeight = UITableView.automaticDimension
        tvList.estimatedRowHeight = 300
        tvList.keyboardDismissMode = .onDrag
        tvList.contentInset = UIEdgeInsets(top: 8.0, left: 0, bottom: 0, right: 0)
    }

    // MARK: - Use Case - Fetch From Local DataStore
    var didAllowToFetchNextData: Bool = false

    func setupFetchFromLocalDataStore() {
        let request = ListModels.FetchFromLocalDataStore.Request()
        interactor?.fetchFromLocalDataStore(with: request)
    }

    func displayFetchFromLocalDataStore(with viewModel: ListModels.FetchFromLocalDataStore.ViewModel) {
    }

    // MARK: - Use Case - Fetch From Remote DataStore
    var displayedItems: [ListModels.FetchFromRemoteDataStore.ViewModel.DisplayedListItem] = []

    func setupFetchFromRemoteDataStore() {
        guard let screenType = router?.dataStore?.listScreenType else {
            return assertionFailure("#Error: Please set screen type")
        }
        let request = ListModels.FetchFromRemoteDataStore.Request(listType: screenType)
        interactor?.fetchFromRemoteDataStore(with: request)
    }

    func displayFetchFromRemoteDataStore(with viewModel: ListModels.FetchFromRemoteDataStore.ViewModel) {
        didAllowToFetchNextData = viewModel.didAllowToFetchNextData
        displayedItems = viewModel.displayedListItem
        tvList.reloadData()
    }

    func displayLoader(type: ListLoaderType) {
        super.showIndicator("Please wait...")
    }

    func hideLoader(type: ListLoaderType) {
        super.hideIndicator()
    }

    func displayError(type: ListErrorType) {
        switch type {
        case .backend:
            return
        default:
            return
        }
    }
}

extension ListViewController: UITableViewDelegate, UITableViewDataSource {

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return displayedItems.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {

        let itemData = displayedItems[indexPath.row]

        if itemData.isLoadingCell {
            guard let cell = tableView.dequeueReusableCell(withIdentifier: LOADING_TABLEVIEW_CELL_ID) as? LoadingTableViewCell else {
                return LoadingTableViewCell.init(style: .default, reuseIdentifier: LOADING_TABLEVIEW_CELL_ID)
            }
            cell.activityIndicator.startAnimating()
            cell.lblTitle.text = itemData.title
            return cell

        } else {
            guard let cell = tableView.dequeueReusableCell(withIdentifier: CUSTOM_TABLEVIEW_CELL_ID) as? CustomTableViewCell else {
                return UITableViewCell()
            }

            cell.lblTitle.text = itemData.title
            cell.lblSubtitle.text = itemData.subTitle
            cell.ivDisclosure.isHidden = !itemData.showDetail
            cell.lblInfo.text = itemData.info
            cell.lblInfo.isHidden = itemData.info == nil //|| itemData.info?.isEmpty()
            if let imageURL = itemData.imageURL {
                cell.ivIcon.isHidden = false
                cell.ivIcon.downloadImageFrom(link: imageURL, contentMode: .scaleAspectFill)
            } else {
                cell.ivIcon.isHidden = true
            }

            return cell
        }

    }

    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let itemData = displayedItems[indexPath.row]
        if !itemData.isLoadingCell {
            router?.routeToNext(showDetail: itemData.showDetail, index: indexPath.row)
        }
    }

    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        let itemData = displayedItems[indexPath.row]
        if itemData.isLoadingCell {
            DispatchQueue.main.asyncAfter(deadline: .now() + 2, execute: {
                self.interactor?.fetchNextPage()
            })
        }
    }

}
