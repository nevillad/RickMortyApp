//
//  ListViewInteractor.swift
//  RickMortyApp
//
//  Created by Nevilkumar Lad on 06/01/22.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit



protocol ListBusinessLogic {
    func fetchFromLocalDataStore(with request: ListModels.FetchFromLocalDataStore.Request)
    func fetchFromRemoteDataStore(with request: ListModels.FetchFromRemoteDataStore.Request)
    func fetchNextPage()
}

protocol ListDataStore {
    var listScreenType: ListType { get set }
    var screenTitle: String { get set }

    var characters: [Character]? { get set }
    var episodes: [Episode]? { get set }
    var locations: [LocationDetails]? { get set }

    /// array index of selected table view cell and used on router to fetch the selected data item
    /// `-1` represents there is no item selected
    var selectdIndex: Int { get set }
    /// total data available for particular entity type. This is used for pagination activity
    var totalCount: Int { get set }
    /// last index of a data returned by server so that next data can be fetched based on it. This is used for pagonation activity
    var lastItemIndex: Int { get set }

    /// To filter out array of authors and quotes based on value provided from caller object.
    var filterKey: String? { get set }
}

class ListInteractor: ListBusinessLogic, ListDataStore {

    // MARK: - Properties

    typealias Models = ListModels

    lazy var worker = ListWorker()
    var presenter: ListPresentationLogic?

    // MARK: - Data Source
    var listScreenType: ListType = .characters
    var screenTitle: String = "Lists"

    var characters: [Character]? = []
    var episodes: [Episode]? = []
    var locations: [LocationDetails]? = []

    var selectdIndex: Int = -1
    var totalCount: Int = 0
    var lastItemIndex: Int = 1
    var pageCount = 0

    var filterKey: String?

    // MARK: - Use Case - Fetch From Local DataStore

    func fetchFromLocalDataStore(with request: ListModels.FetchFromLocalDataStore.Request) {
        let response = Models.FetchFromLocalDataStore.Response()
        presenter?.presentFetchFromLocalDataStore(with: response)
    }

    // MARK: - Use Case - Fetch From Remote DataStore

    func fetchFromRemoteDataStore(with request: ListModels.FetchFromRemoteDataStore.Request) {
        // Show loader for the first time only. in case of pagination data will be reload and loader would be shown in the last cell
        self.presenter?.presentLoader(type: .general)
        self.fetchFromServer()
    }

    private func fetchFromServer() {
        switch listScreenType {
        case .characters: getCharacters()
        case .episodes: getEpisodes()
        case .locations: getLocations()
        }
    }

    private func getCharacters() {
        let finalUrl = ApiActions.getCharacters.finalURL + "?page=\(self.lastItemIndex)"

         //+ "?limit=\(limit)&skip=\(lastItemIndex)"
        let resource = Resource<CharacterData>(url: finalUrl)
        debugPrint("Final url is: \(resource.url)")

        NetworkServices.fetchJson(resource: resource) { result in
            self.presenter?.hideLoader(type: .general)
            switch result {
            case .success(let characterData):
                self.characters?.append(contentsOf: characterData.results)

                //self.totalCount = characterData.info.count ?? self.characters?.count ?? 0

                /// if self.lastItemIndex == 1 it is assumed that there is no further data to show otherwise it will load same data again and again to create infinite loop.
                debugPrint(characterData.results.count)
                if characterData.info.next != nil {
                    self.lastItemIndex += 1
                }
                let allowToPaginate = self.lastItemIndex != 1 && self.lastItemIndex <= characterData.info.pages

                let response = ListModels.FetchFromRemoteDataStore.Response(episodes: nil, characters: self.characters, locations: nil, didAllowToFetchNextData: allowToPaginate)
                self.presenter?.presentFetchFromRemoteDataStore(with: response)
                break
            case .failure(let error):
                self.presenter?.presentError(type: .custom(message: error.localizedDescription))
            }
        }
    }

    private func getEpisodes() {
        let finalUrl = ApiActions.getEpisodes.finalURL + "?page=\(self.lastItemIndex)"
        let resource = Resource<EpisodesData>(url: finalUrl)
        debugPrint("Final url is: \(resource.url)")

        NetworkServices.fetchJson(resource: resource) { result in
            self.presenter?.hideLoader(type: .general)
            switch result {
            case .success(let episodesData):
                self.episodes?.append(contentsOf: episodesData.results ?? [])

                if episodesData.info.next != nil {
                    self.lastItemIndex += 1
                }
                let allowToPaginate = self.lastItemIndex != 1 && self.lastItemIndex <= episodesData.info.pages

                let response = ListModels.FetchFromRemoteDataStore.Response(episodes: self.episodes, characters: nil, locations: nil, didAllowToFetchNextData: allowToPaginate)
                self.presenter?.presentFetchFromRemoteDataStore(with: response)


                break
            case .failure(let error):
                self.presenter?.presentError(type: .custom(message: error.localizedDescription))
            }
        }
    }

    private func getLocations() {
        let finalUrl = ApiActions.getLocations.finalURL
        let resource = Resource<LocationData>(url: finalUrl)
        debugPrint("Final url is: \(resource.url)")

        NetworkServices.fetchJson(resource: resource) { result in
            self.presenter?.hideLoader(type: .general)
            switch result {
            case .success(let locationData):
                self.locations?.append(contentsOf: locationData.results)

                if locationData.info.next != nil {
                    self.lastItemIndex += 1
                }
                let allowToPaginate = self.lastItemIndex != 1 && self.lastItemIndex <= locationData.info.pages

                let response = ListModels.FetchFromRemoteDataStore.Response(episodes: nil, characters: nil, locations: self.locations, didAllowToFetchNextData: allowToPaginate)
                self.presenter?.presentFetchFromRemoteDataStore(with: response)


            case .failure(let error):
                self.presenter?.presentError(type: .custom(message: error.localizedDescription))
            }
        }
    }

    func fetchNextPage() {
        self.fetchFromServer()
    }
}


/*

protocol ListViewBusinessLogic {
    func doListViewDetails(request: ListViewModel.ListViewDetails.Request)
    func initialise(showLoader: Bool)
}

protocol ListViewDataStore {
    //var name: String { get set }
}

class ListViewInteractor: ListViewBusinessLogic, ListViewDataStore {
    var presenter: ListViewPresentationLogic?
    var worker: ListViewWorker?
    //var name: String = ""

    // MARK: Do ListViewDetails

    func doListViewDetails(request: ListViewModel.ListViewDetails.Request)
    {
        worker = ListViewWorker()
        worker?.doSomeWork()

        let response = ListViewModel.ListViewDetails.Response()
        presenter?.presentListViewDetails(response: response)
    }

    func initialise(showLoader: Bool = true) {
    }
}
*/
